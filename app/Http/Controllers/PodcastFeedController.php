<?php

namespace App\Http\Controllers;

use App\Models\Episode;
use App\Models\Setting;
use Illuminate\Http\Response;

class PodcastFeedController extends Controller
{
    public function index(): Response
    {
        $settings = Setting::singleton();

        // 1) Optional HTTP redirect for the whole feed (server-side)
        if (($settings->feed_redirect_enabled ?? false) && !empty($settings->feed_redirect_url)) {
            return response('', 301)->withHeaders([
                'Location'       => $settings->feed_redirect_url,
                'Cache-Control'  => 'no-store',
            ]);
        }

        // 2) Site/feed meta (fallbacks keep your feed robust)
        $site = [
            'title'   => $settings->site_title        ?? config('app.name', 'Powerpod'),
            'link'    => rtrim((string)($settings->site_link ?? config('app.url')), '/'),
            'desc'    => $settings->site_desc         ?? 'Podcast feed generated by Powerpod',
            'lang'    => $settings->site_lang         ?? 'en-us',
            // iTunes / Apple
            'itunes_author'   => $settings->site_itunes_author ?? null,
            'itunes_summary'  => $settings->site_itunes_summary ?? null,
            'itunes_image'    => $settings->site_itunes_image ?? null,
            'owner_name'      => $settings->site_owner_name ?? null,
            'owner_email'     => $settings->site_owner_email ?? null,
            'explicit'        => (bool)($settings->feed_explicit ?? false),
            'category'        => $settings->site_category ?? 'Technology',
            'type'            => $settings->site_type ?? 'episodic', // episodic|serial

            // Advanced feed flags
            'apple_summary'           => $settings->feed_apple_summary ?? '',
            'episode_link_mode'       => $settings->feed_episode_link ?? 'podpower', // podpower|external
            'episode_artwork_tag'     => $settings->feed_episode_artwork_tag ?? 'itunes', // itunes|episode
            'apple_verification'      => (bool)($settings->feed_apple_verification ?? false),
            'remove_from_directory'   => (bool)($settings->feed_remove_from_directory ?? false),
            'set_new_feed_url'        => (bool)($settings->feed_set_new_feed_url ?? false),
            'new_feed_url'            => $settings->feed_redirect_url ?? null, // used in <itunes:new-feed-url>, not for HTTP redirect
        ];

        // 3) Episode query with configurable limit
        $limit = (int)($settings->feed_episode_limit ?? 100);
        if ($limit < 1)   $limit = 1;
        if ($limit > 1000) $limit = 1000;

        $episodes = Episode::query()
            ->where('status', 'published')
            ->whereNotNull('published_at')
            ->orderByDesc('published_at')
            ->orderByDesc('id')
            ->limit($limit)
            ->get();

        // 4) Strong ETag that also changes when settings change
        $etag = '"'.sha1(json_encode([
            'max_updated_episode' => optional($episodes->max('updated_at'))->toISOString(),
            'count'               => $episodes->count(),
            'site_link'           => $site['link'],
            'settings_updated_at' => optional($settings->updated_at)->toISOString(),
        ])).'"';

        $clientTag = request()->header('If-None-Match');
        if ($clientTag && trim($clientTag) === $etag) {
            return response('', 304)->withHeaders([
                'ETag'           => $etag,
                'Cache-Control'  => 'public, max-age=300',
                'Vary'           => 'Accept-Encoding',
            ]);
        }

        // 5) Render XML view with everything the template needs
        $xml = view('feed.podcast', [
            'site'     => $site,
            'episodes' => $episodes,
        ])->render();

        return response($xml, 200)->withHeaders([
            'Content-Type'  => 'application/rss+xml; charset=UTF-8',
            'Cache-Control' => 'public, max-age=300',
            'ETag'          => $etag,
            'Vary'          => 'Accept-Encoding',
        ]);
    }
}
