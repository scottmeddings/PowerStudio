<?php

namespace App\Http\Controllers;

use App\Models\Episode;
use App\Models\Setting;
use Illuminate\Http\Response;
use Illuminate\Support\Str;
use Illuminate\Support\Carbon;

class PodcastFeedController extends Controller
{
    public function index(?string $slug = null): Response
    {
        $settings = Setting::singleton();

        // If the slug is present in the URL, enforce the configured one
        $expected = $settings->podcast_subdomain ?: Str::slug($settings->site_title ?: 'podcast', '-');
        if ($slug !== null && $slug !== $expected) {
            return redirect()->to(url("/{$expected}/feed.xml"), 301);
        }

        // Optional HTTP redirect for the whole feed (server-side)
        if (($settings->feed_redirect_enabled ?? false) && !empty($settings->feed_redirect_url)) {
            return response('', 301)->withHeaders([
                'Location'      => $settings->feed_redirect_url,
                'Cache-Control' => 'no-store',
            ]);
        }

        // Site/feed meta
        $site = [
            'title' => $settings->site_title ?? 'MyPodcast',
            'link'    => rtrim((string)($settings->site_link ?? config('app.url')), '/'),
            'desc'    => $settings->site_desc         ?? 'Podcast feed generated by Powerpod',
            'lang'    => $settings->site_lang         ?? 'en-us',
            'itunes_author'  => $settings->site_itunes_author ?? null,
            'itunes_summary' => $settings->site_itunes_summary ?? null,
            'itunes_image'   => $settings->site_itunes_image ?? null,
            'owner_name'     => $settings->site_owner_name ?? null,
            'owner_email'    => $settings->site_owner_email ?? null,
            'explicit'       => (bool)($settings->feed_explicit ?? false),
            'category'       => $settings->site_category ?? 'Technology',
            'type'           => $settings->site_type ?? 'episodic',
            // Advanced feed flags
            'apple_summary'         => $settings->feed_apple_summary ?? '',
            'episode_link_mode'     => $settings->feed_episode_link ?? 'podpower',   // podpower|external
            'episode_artwork_tag'   => $settings->feed_episode_artwork_tag ?? 'itunes',
            'apple_verification'    => (bool)($settings->feed_apple_verification ?? false),
            'remove_from_directory' => (bool)($settings->feed_remove_from_directory ?? false),
            'set_new_feed_url'      => (bool)($settings->feed_set_new_feed_url ?? false),
            'new_feed_url'          => $settings->feed_redirect_url ?? null, // for <itunes:new-feed-url>
        ];

        // Episodes with configurable limit
        $limit = max(1, min((int)($settings->feed_episode_limit ?? 100), 1000));
        $episodes = Episode::query()
            ->where('status', 'published')
            ->whereNotNull('published_at')
            ->orderByDesc('published_at')
            ->orderByDesc('id')
            ->limit($limit)
            ->get();

        // Robust ETag (also changes when settings change)
        $maxUpdated = $episodes->max('updated_at'); // may be Carbon or string or null
        $maxUpdatedIso = $maxUpdated
            ? ($maxUpdated instanceof \Carbon\CarbonInterface
                ? $maxUpdated->toIso8601String()
                : Carbon::parse($maxUpdated)->toIso8601String())
            : null;

        $etag = '"'.sha1(json_encode([
            'max_updated_episode' => $maxUpdatedIso,
            'count'               => $episodes->count(),
            'site_link'           => $site['link'],
            'settings_updated_at' => optional($settings->updated_at)->toIso8601String(),
        ])).'"';

        if (($clientTag = request()->header('If-None-Match')) && trim($clientTag) === $etag) {
            return response('', 304)->withHeaders([
                'ETag'          => $etag,
                'Cache-Control' => 'public, max-age=300',
                'Vary'          => 'Accept-Encoding',
            ]);
        }

        // Render XML
        $xml = view('feed.podcast', [
            'site'     => $site,
            'episodes' => $episodes,
        ])->render();

        return response($xml, 200)->withHeaders([
            'Content-Type'  => 'application/rss+xml; charset=UTF-8',
            'Cache-Control' => 'public, max-age=300',
            'ETag'          => $etag,
            'Vary'          => 'Accept-Encoding',
        ]);
    }
}
